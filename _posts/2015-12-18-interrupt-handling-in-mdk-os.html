---
layout: post
title: Interrupt handling in the MDK OS.
date: '2015-12-18T23:45:00.001+05:30'
author: Gautam Bhat
tags:
- mini2440
- interrupt
- mdkos
- baremetal OS
modified_time: '2015-12-18T23:49:04.204+05:30'
blogger_id: tag:blogger.com,1999:blog-2655423030126048565.post-4441350537810854677
blogger_orig_url: https://thesoulofamachine.blogspot.com/2015/12/interrupt-handling-in-mdk-os.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">In ARM microprocessors the memory map address 0x00000000 is reserved for the vector table which is a set of 32bit words. When an interrupt occurs the processors suspends normal execution and starts loading instructions from the exception vector table. It is usually contains a form of branch instruction to a particular routine.<br /><br />The interrupt vector table is as follows:<br /><br /><table border="2" bordercolor="#00000000" cellpadding="1" cellspacing="1" style="background-color: #FFFFFFFF;"><tbody><tr><th>Vector</th><th>Address</th></tr><tr><td>Reset</td><td>0x00000000</td></tr><tr><td>Undefined</td><td>0x00000004</td></tr><tr><td>SWI</td><td>0x00000008</td></tr><tr><td>PABT</td><td>0x0000000C</td></tr><tr><td>DABT</td><td>0x00000010</td></tr><tr><td>Reserved</td><td>0x00000014</td></tr><tr><td>IRQ</td><td>0x00000018</td></tr><tr><td>FIQ</td><td>0x00000018</td></tr></tbody></table><br /><br />In the S3C2440 after a power on reset the initial 4KB of the NAND flash memory will be loaded onto an internal boot SRAM called the "stepping stone" buffer and the boot code present in this memory address will be executed. The loader is flashed onto the NAND flash using supervivi.<br /><br /><h4 style="text-align: left;"><b><u>Interrupt handling in loader</u></b>:</h4>The "stepping stone" buffer SRAM memory map address is located at 0x00000000. Hence our MDK loader gets executed from there. The MDK loader has the following code at the start:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;">.section .text<br />.code 32<br />.globl vectors<br /><br />vectors:<br /> b reset  /* Reset */<br /> b fault_state  /* Undefined instruction */<br /> b fault_state /* Software Interrupt */<br /> b fault_state  /* Abort prefetch */<br /> b fault_state  /* Abort data */<br /> b .  /* Reserved */<br /> b fault_state /* IRQ */<br /> b fault_state /* FIQ */<br /></pre></div><br />The code is placed in .text section. The addresses in this section is generated from 0x00000000. The fragment of the loader script is below:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;">MEMORY<br />{<br /> sram : org = 0x00000000 , len = 0x1000<br /> sdram : org = 0x30000000 , len = 0x4000000<br />}<br /><br />SECTIONS<br />{<br /> .text :<br /> {<br />  *(.text);<br />  . = ALIGN(4);<br /> } &gt; sram<br /></pre></div><br />As shown above the section .text is loaded onto the sram section which has origin from 0x00000000 with the length of 0x1000(4096) or 4KB.<br /><br />Notice that my reset vector contains a branch to the reset label. The reset code fragment is as follows:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15</pre></td><td><pre style="line-height: 125%; margin: 0;">reset:<br /> /* Start by clearing bss section */<br /> ldr r1, bss_start<br /> ldr r2, bss_end<br /> ldr r3, =0<br /><br />clear_bss:<br /> cmp r1,r2<br /> str r3,[r1],#4<br /> bne clear_bss<br /><br /> /* load r13 i.e. stack pointer with stack_pointer */<br /> ldr r13,stack_pointer<br /><br /> bl main<br /></pre></td></tr></tbody></table></div><br />Here I load the bss_start and bss_end as present in the linker script file. Next in the clear_bss I compare if r1 i.e. the bs_start has reached r2 i.e the bs_end. I clear the bss by storing r3 in r1 memory content and incrementing it by 4. Then if I have not equaled r2 I continue the loop. Else I load the stack pointer in r13 and branch to main. The main is the main() function in os_main.c file.<br /><br />Where have I got the stack_pointer,bss_start and bss_end variables from?<br /><br />The code fragment below explains:&nbsp; <br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3</pre></td><td><pre style="line-height: 125%; margin: 0;">stack_pointer: .word __stack_top__<br />bss_start : .word __bss_start__<br />bss_end : .word __bss_end__<br /></pre></td></tr></tbody></table></div><br />Where did the __stack_top__,__bss_start__ and __bss_end__ come from?<br /><br />The linker script code explains:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27</pre></td><td><pre style="line-height: 125%; margin: 0;">SECTIONS<br />{<br /> .text :<br /> {<br />  *(.text);<br />  . = ALIGN(4);<br /> } &gt; sram<br /><br /> .data :<br /> {<br />  __data_start__ = .;<br />  *(.data)<br />  . = ALIGN(4);<br />  __data_end__ = .;<br /> } &gt; sram<br /><br /> .bss  :<br /> {<br />  __bss_start__ = .;<br />  *(.bss); *(COMMON)<br />  __bss_end__ = .;<br /><br />  __stack_bottom__ = .;<br />  . += 0x300;<br />  __stack_top__ = .;<br /><br /> } &gt; sram<br /></pre></td></tr></tbody></table></div><br />Notice that the linker script variables has global visibility. Now we can take the generated address and use it in our code. Notice that the __stack_bottom__ and __stack_top__ has 0x300(768) bytes of space. Please note that we are loading __stack_top__ in r13(SP) as the stack is a descending stack.<br /><br />We are not handling any other interrupts in the loader. So if there are any interrupts that happens we just jump to a fault state as shown below:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13</pre></td><td><pre style="line-height: 125%; margin: 0;">fault_state:<br /> ldr r3,GPBCON<br /> ldr r4,GPBDAT<br /> ldr r5,GPBUP<br /><br /> ldr r6,=0x15400<br /> str r6,[r3]  @Set to output<br /> ldr r6,=0x00<br /> str r6,[r4]  @Set the led<br /> ldr r6,=0x1E0<br /> str r6,[r5]  @Disable pullup <br /><br /> b .<br /></pre></td></tr></tbody></table></div><br />I have setup the LED's to glow so that I understand that I am in a fault state.<br /><br />This completes interrupt handling in the loader after a Power on Reset. Next we will see how we will handle this in the MDK OS.<br /><br /><h4 style="text-align: left;"><u><b>Interrupt handling in MDK OS</b></u>:</h4><div style="text-align: left;">In the MDK OS the interrupt handling will be done differently. We face several problems with using the initial vectors to jump to a particular interrupt handling routine. First is that if we want to jump to a routine which is placed in the SDRAM at address 0x30000000 it becomes too far a jump.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">So how did I fix this? I enabled the MMU and mapped address 0x00000000 to EXCEPTION_INTERRUPT_VECTOR_TABLE_START which is presently hard coded to 0x33F00000. So now whenever the processor jumps to 0x00000000 it will do an address translation and translates it to 0x33F00000 and executes the content at that address.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">So how is the implementation done?</div><div style="text-align: left;"><br /></div><div style="text-align: left;">First we visit the code where the exception vectors are written(os_vectors.s).</div><div style="text-align: left;"><br /></div><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16</pre></td><td><pre style="line-height: 125%; margin: 0;">.section .vector_reloc,"ax" //Apparent fix for missing section when objcopy is to have allocatable and executable flags-"ax"<br /><br />.code 32<br /><br />.globl exception_vectors<br /><br />exception_vectors:<br /> ldr pc,=do_handle_reset  //Reset vector<br /> ldr pc,=do_handle_undef  //Undefined instruction<br /> ldr pc,=do_handle_swi   //Software Interrupt<br /> ldr pc,=do_handle_pabt   //Abort prefetch<br /> ldr pc,=do_handle_dabt  //Abort data<br /> ldr pc,=do_handle_reserved //Reserved<br /> ldr pc,=do_handle_irq  //IRQ<br /> ldr pc,=do_handle_fiq  //FIQ<br />.end<br /></pre></td></tr></tbody></table></div><br />The code is put at section .vector_reloc (intuitive name vector relocation).<br /><br />The exception vector code by itself is very simple. It just loads the PC (Program Counter) register with the different exception handlers.<br /><br />How is the address generated for the code? It would be EXCEPTION_INTERRUPT_VECTOR_TABLE_START.<br /><br />How is the above address generation determined? We have to look at the linker script of the MDK OS(mdkos.lds).<br /><br />First we look the memory section:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3<br />4<br />5<br />6<br />7</pre></td><td><pre style="line-height: 125%; margin: 0;">MEMORY<br />{<br /> sram : org = 0x00000000 , len = 0x1000<br /> /*sdram : org = 0x30000000 , len = 0x4000000*/<br /> sdram : org = 0x30000000 , len = 0x3F00000 /* 63MB RAM */<br /> vectors : org = 0x33F00000 , len = 0x100000 /* Last 1MB for the isr handlers */<br />}<br /></pre></td></tr></tbody></table></div><br />I have defined vectors region starting at 0x33F00000.<br /><br />Next we see the sections:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">  1<br />  2<br />  3<br />  4<br />  5<br />  6<br />  7<br />  8<br />  9<br /> 10<br /> 11<br /> 12<br /> 13<br /> 14<br /> 15<br /> 16<br /> 17<br /> 18<br /> 19<br /> 20<br /> 21<br /> 22<br /> 23<br /> 24<br /> 25<br /> 26<br /> 27<br /> 28<br /> 29<br /> 30<br /> 31<br /> 32<br /> 33<br /> 34<br /> 35<br /> 36<br /> 37<br /> 38<br /> 39<br /> 40<br /> 41<br /> 42<br /> 43<br /> 44<br /> 45<br /> 46<br /> 47<br /> 48<br /> 49<br /> 50<br /> 51<br /> 52<br /> 53<br /> 54<br /> 55<br /> 56<br /> 57<br /> 58<br /> 59<br /> 60<br /> 61<br /> 62<br /> 63<br /> 64<br /> 65<br /> 66<br /> 67<br /> 68<br /> 69<br /> 70<br /> 71<br /> 72<br /> 73<br /> 74<br /> 75<br /> 76<br /> 77<br /> 78<br /> 79<br /> 80<br /> 81<br /> 82<br /> 83<br /> 84<br /> 85<br /> 86<br /> 87<br /> 88<br /> 89<br /> 90<br /> 91<br /> 92<br /> 93<br /> 94<br /> 95<br /> 96<br /> 97<br /> 98<br /> 99<br />100<br />101<br />102<br />103<br />104<br />105<br />106<br />107</pre></td><td><pre style="line-height: 125%; margin: 0;">SECTIONS<br />{<br /><br /> .text :<br /> {<br />  *(.text);<br />  . = ALIGN(4);<br /> } &gt; sdram<br /><br /><br /> .data :<br /> {<br />  __data_start__ = .;<br />  *(.data);<br />  . = ALIGN(4);<br />  __data_end__ = .;<br /> } &gt; sdram<br /><br />/*<br /> * Note on constant string bug (related to .rodata): <br /> * There was a bug initially when printing a string constant would make the <br /> * device go into a loop printing nonsense. This was due the fact that .rodata section<br /> * was left out. Due to this the addresses of the constant was emitted after the interrupt<br /> * vectors but the actual address of the constant was somewhere in between the file. (it<br /> * was after the stack setup. All the functions which referred to the string would use<br /> * the address which was emitted at the end of the isr handlers but the string was sitting<br /> * way before. It would have worked if after startup the string was moved to the address<br /> * at the end of the isr handler. Instead of doing this we can create a .rodata section and<br /> * put in the RAM. Also make sure we don't overwrite the read only section with some <br /> * method. We can later write the .rodata to say flash and lock the write and do only a<br /> * read.<br /> */<br /> .rodata :<br /> {<br />  __rodata_start__ = .;<br />  *(.rodata);<br />  . = ALIGN(4);<br />  __rodata_end__ = .;<br /> } &gt; sdram<br /><br /> .bss  :<br /> {<br />  __bss_start__ = .;<br />  *(.bss); *(COMMON)<br />  __bss_end__ = .;<br /><br />  __usr_sys_stack_bottom__ = .;<br />  . += 0x1000;<br />  __usr_sys_stack_top__ = .;<br /><br />  __irq_stack_bottom__ = .;<br />  . += 0x1000;<br />  __irq_stack_top__ = .;<br /><br />  __fiq_stack_bottom__ = .;<br />  . += 0x1000;<br />  __fiq_stack_top__ = .;<br /><br />  __svc_stack_bottom__ = .;<br />  . += 0x1000;<br />  __svc_stack_top__ = .;<br /> } &gt; sdram<br /><br /> <br /> .vector_reloc :<br /> {<br />  *(.vector_reloc);<br /> } &gt;vectors AT&gt;sdram <br /><br /> /* Get the lma address for the particular section */<br /> __exception_vector_reloc_startaddr__ = LOADADDR(.vector_reloc);<br /> __exception_vector_reloc_endaddr__ = LOADADDR(.vector_reloc) + SIZEOF(.vector_reloc);<br /><br /> /* <br />     * Above SDRAM is where it will be stored in the file but address<br />     * references will be in the addresses of the isr handler section<br />  */<br /><br /><br /> .isrhandler :<br /> {<br />  *(.isrhandler);<br /> } &gt;vectors AT&gt;sdram<br /><br /> __exception_handler_start_addr__ = LOADADDR(.isrhandler);<br /> __exception_handler_end_addr__ = LOADADDR(.isrhandler) +  SIZEOF(.isrhandler);<br /><br /><br /> /* <br />  * &gt;vma region AT &gt; lma region <br />  */<br /><br /> /* <br />  * eg: .data section is linked with LMA in ROM and<br />  * the VMA pointing to the real RAM versions<br />  */<br /><br /> .stab 0 (NOLOAD) : <br /> {<br />  [ .stab ]<br /> }<br /><br /> .stabstr 0 (NOLOAD) :<br /> {<br />  [ .stabstr ]<br /> }<br />}<br /></pre></td></tr></tbody></table></div><br />In line 65 vector_reloc part I tell the linker to generate addresses in the range defined by vectors i.e. from 0x33F00000. This will be the VMA region.<br /><br />Now how do I know where the code is loaded?<br />The code is loaded by the loader to address 0x30000000 which is the start of the SDRAM. The code is placed after the .bss section. The __exception_vector_reloc_startaddr__ and __exception_vector_reloc_endaddr__ contains the start and end of the exception handler vector section. So when the code is loaded the place where it be present is 0x30XXXXXX. This will be the LMA region. The code has to be loaded from this region to the EXCEPTION_INTERRUPT_VECTOR_TABLE_START(0x3F000000) region. <br /><br />The loading of these code is done the following way(setup_interrupt_vector_table(..) in os/mmu.c):<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-weight: bold;">static</span> <span style="color: #333399; font-weight: bold;">void</span> <span style="color: #0066bb; font-weight: bold;">setup_interrupt_vector_table</span>()<br />{<br /><span style="color: #888888;">/*</span><br /><span style="color: #888888;"> * TODO: Optimize it to remove the extra index variables. Unoptimized only for test purposes.</span><br /><span style="color: #888888;"> *</span><br /><span style="color: #888888;"> */</span><br /><br /> <span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>vector_table <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>)EXCEPTION_INTERRUPT_VECTOR_TABLE_START;<br /><br /> <span style="color: #888888;">/* </span><br /><span style="color: #888888;">  * Need to get the lma of the code.</span><br /><span style="color: #888888;">  * The __exception_vector_reloc_startaddr__ is the lma i.e. the generated </span><br /><span style="color: #888888;">  * address in the file. I need to use this as the start address for the </span><br /><span style="color: #888888;">  * later vectors and handlers.</span><br /><span style="color: #888888;">  */</span><br /><br /> <span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>src <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>)__exception_vector_reloc_startaddr__; <br />      <br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> i <span style="color: #333333;">=</span> <span style="color: #0000dd; font-weight: bold;">0</span>;<br /><br /> <span style="color: #008800; font-weight: bold;">for</span>(i <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_vector_reloc_startaddr__; <br />   i<span style="color: #333333;">&lt;</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_vector_reloc_endaddr__; <br />    i<span style="color: #333333;">++</span>) {<br />  <span style="color: #333333;">*</span>vector_table <span style="color: #333333;">=</span> <span style="color: #333333;">*</span>src;<br />  vector_table<span style="color: #333333;">++</span>;<br />  src<span style="color: #333333;">++</span>;<br /> }<br /><br /><br /> <span style="color: #888888;">/* Continue with the same place for handler source  */</span><br /> <span style="color: #008800; font-weight: bold;">for</span>(i <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_handler_start_addr__; <br />     i<span style="color: #333333;">&lt;</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_handler_end_addr__;<br />     i<span style="color: #333333;">++</span>) {<br />  <span style="color: #333333;">*</span>vector_table <span style="color: #333333;">=</span> <span style="color: #333333;">*</span>src;<br />  vector_table<span style="color: #333333;">++</span>;<br />  src<span style="color: #333333;">++</span>;<br /> }<br /><br />}<br /></pre></td></tr></tbody></table></div><br /><br /><br />In line 17 we get the content from "vectoreloc" start address to end address and we copy it to the vector_table pointer pointing to EXCEPTION_INTERRUPT_VECTOR_TABLE_START i.e. 0x3F000000 address.<br /><br />Apart from that we continue to copy the contents of the interrupt handlers. The isr handlers are placed right next to the exception handlers.<br /><br />The interrupt service handlers are placed in file exception_handler.s under the section .isrhandler<br /><br />The code fragment is as follows:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52<br />53<br />54<br />55<br />56<br />57<br />58<br />59<br />60<br />61<br />62<br />63<br />64<br />65<br />66<br />67<br />68<br />69<br />70<br />71<br />72<br />73<br />74<br />75<br />76<br />77<br />78<br />79<br />80<br />81<br />82<br />83<br />84<br />85<br />86<br />87<br />88</pre></td><td><pre style="line-height: 125%; margin: 0;">.section .isrhandler,"ax"<br /><br /><br />.code 32<br /><br /><br />.globl do_handle_reset<br />do_handle_reset:<br /> b do_handle_reset<br /><br />.globl do_handle_undef<br />do_handle_undef:<br /> b do_handle_undef<br /><br />.globl do_handle_swi<br />do_handle_swi:<br /> b do_handle_swi<br /><br />.globl do_handle_pabt<br />do_handle_pabt:<br /> b do_handle_pabt<br /><br />.globl do_handle_dabt<br />do_handle_dabt:<br /> b do_handle_dabt<br /><br />.globl do_handle_reserved<br />do_handle_reserved:<br /> b do_handle_reserved<br /><br /><br />.globl do_handle_irq<br />do_handle_irq:<br /> sub lr,lr,#4 @Subtract r14(lr) by 4.<br /> stmfd sp!, {r0-r12,lr} @Save r0-r12 and lr. <br />       @sp! indicates sp will be subtracted by the sizes of the registers saved.<br />       @Instruction details can be read in ARM System Developers guide book at Pg 65.<br /> /*<br />  * Note on disabling and enabling CPU IRQ.<br />  * ======================================<br />  * There is no need to disable IRQ when in IRQ mode. When there is <br />  * an interrupt the processor switches to IRQ mode with the I bit <br />  * enabled which means it is masked.<br />  *<br />  * It was tested by printing the cpsr_irq which had the value<br />  * 0x60000092. The 7th bit is set which means the IRQ flag is set.<br />  *<br />  * This is the same case with the FIQ.<br />  */<br /> <br /> ldr r2,INTOFFSET    @Load the INTOFFSET value into r2<br /> ldr r2,[r2]      @Load the value in the address to r2<br /> <br /><br /> ldr r3,=interrupt_handler_jmp_table @Load the address of the interrupt handler jump table.<br /><br /> mov lr,pc<br /> ldr pc,[r3,r2,LSL #2] @Load the value which is the interrupt handler jmp table.<br /><br /><br />// bl handle_irq<br /><br /> //Clear interrupt source pending<br /><br /> ldr r2,INTOFFSET    @Load the INTOFFSET value into r2<br /> ldr r2,[r2]      @Load the value in the address to r2<br /><br /> mov r3,#1    @move 1 to r3.<br /> mov r3,r3, LSL r2   @Shift left by INTOFFSET and store it in r3<br /> <br /> ldr r4,SRCPND<br /> str r3,[r4]   @Store the value of r3 in r4 address<br /><br /> ldr r4,INTPND<br /> str r3,[r4]   @Store the value of r3 in r4 address<br /><br /> <br /> <br /> ldmfd sp!, {r0-r12,pc}^  @Restore the stack values to r0 and r12. Next restore lr to pc.<br />       @The ^ indicates the spsr has to copied to cpsr. The cpsr was copied to spsr<br />       @when the interrupt was generated.<br />       @The restoration of CPSR will change the mode to whatever mode was<br />       @present before the interrupt was called.<br /> <br /><br />.globl do_handle_fiq<br />do_handle_fiq:<br />  b do_handle_fiq<br /></pre></td></tr></tbody></table></div><br /><br />The code in os_vector.s for e.g. where the ldr pc,=do_handle_irq was done has the code of do_handle_irq in the file exception_handler.s which contains the implementation.<br /><br />This concludes the memory juggling needed to execute the interrupts.<br /><br /><h4 style="text-align: left;"><u>Handling of various IRQ's</u>:</h4><div style="text-align: left;">To get an interrupt you have to enable the global IRQ and FIQ in the CPSR register. This is done as follows:</div><div style="text-align: left;"></div><div style="text-align: left;"><br /></div><div style="text-align: left;"></div><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-weight: bold;">static</span> <span style="color: #333399; font-weight: bold;">void</span> <span style="color: #0066bb; font-weight: bold;">enable_irq_fiq</span>(<span style="color: #333399; font-weight: bold;">void</span>)<br />{<br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> cpsr_val <span style="color: #333333;">=</span> <span style="color: #0000dd; font-weight: bold;">0</span>;<br /><br /> __asm__ __volatile__ (<br />  <span style="background-color: #fff0f0;">"mrs r0,cpsr</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span>   <span style="color: #888888;">/* Copy CPSR to r0 */</span><br />  <span style="background-color: #fff0f0;">"bic r0,r0,#0xC0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span>  <span style="color: #888888;">/* Clear IRQ, FIQ */</span><br />  <span style="background-color: #fff0f0;">"msr cpsr,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span>   <span style="color: #888888;">/* Copy modified value to cpsr */</span><br />  <span style="background-color: #fff0f0;">"mov %0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />  <span style="color: #333333;">:</span> [cpsr_val]<span style="background-color: #fff0f0;">"=r"</span>(cpsr_val) <span style="color: #888888;">/* No output */</span><br />  <span style="color: #333333;">:</span> <span style="color: #888888;">/* No input */</span><br />  <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">"r0"</span> <span style="color: #888888;">/* r0 gets clobbered */</span><br /> );<br /><br /> <span style="color: #888888;">//print_hex_uart(UART0_BA,cpsr_val);</span><br />}<br /></pre></td></tr></tbody></table></div><br />An optimization would be to rewrite as a macro.<br /><br />Next we will go to the actual handling of the interrupt exception. For this we have to turn over to the code in exception_hander.s<br /><br />In the do_handle_irq we have :<br /><br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52</pre></td><td><pre style="line-height: 125%; margin: 0;">do_handle_irq:<br /> sub lr,lr,#4 @Subtract r14(lr) by 4.<br /> stmfd sp!, {r0-r12,lr} @Save r0-r12 and lr. <br />       @sp! indicates sp will be subtracted by the sizes of the registers saved.<br />       @Instruction details can be read in ARM System Developers guide book at Pg 65.<br /> /*<br />  * Note on disabling and enabling CPU IRQ.<br />  * ======================================<br />  * There is no need to disable IRQ when in IRQ mode. When there is <br />  * an interrupt the processor switches to IRQ mode with the I bit <br />  * enabled which means it is masked.<br />  *<br />  * It was tested by printing the cpsr_irq which had the value<br />  * 0x60000092. The 7th bit is set which means the IRQ flag is set.<br />  *<br />  * This is the same case with the FIQ.<br />  */<br /> <br /> ldr r2,INTOFFSET    @Load the INTOFFSET value into r2<br /> ldr r2,[r2]      @Load the value in the address to r2<br /> <br /><br /> ldr r3,=interrupt_handler_jmp_table @Load the address of the interrupt handler jump table.<br /><br /> mov lr,pc<br /> ldr pc,[r3,r2,LSL #2] @Load the value which is the interrupt handler jmp table.<br /><br /><br />// bl handle_irq<br /><br /> //Clear interrupt source pending<br /><br /> ldr r2,INTOFFSET    @Load the INTOFFSET value into r2<br /> ldr r2,[r2]      @Load the value in the address to r2<br /><br /> mov r3,#1    @move 1 to r3.<br /> mov r3,r3, LSL r2   @Shift left by INTOFFSET and store it in r3<br /> <br /> ldr r4,SRCPND<br /> str r3,[r4]   @Store the value of r3 in r4 address<br /><br /> ldr r4,INTPND<br /> str r3,[r4]   @Store the value of r3 in r4 address<br /><br /> <br /> <br /> ldmfd sp!, {r0-r12,pc}^         @Restore the stack values to r0 and r12. Next restore lr to pc.<br />     @The ^ indicates the spsr has to copied to cpsr. The cpsr was copied to spsr<br />     @when the interrupt was generated.<br />     @The restoration of CPSR will change the mode to whatever mode was<br />     @present before the interrupt was called.<br /> <br /></pre></td></tr></tbody></table></div><br />Before we go in depth into the explanation of the code there is a need to explain the first line of the code.<br />When an exception occurs the link register is set to a specific address based on the current pc. When an IRQ exception is raised the link register lr points to the last executed instruction plus 8. Care has to be taken to make sure the exception handler does not corrupt the lr because lr is used to return from an exception handler. The IRQ exception is taken only after the current instruction is executed, so the return address has to point to the next instruction i.e. lr-4.<br /><br />The following has useful addresses for the different exceptions. <br /><br /><table border="2" bordercolor="#00000000" cellpadding="1" cellspacing="1" style="background-color: #FFFFFFFF;"><tbody><tr><th>Exception</th><th>Address</th></tr><tr><td>Reset</td><td><br /></td></tr><tr><td>Undefined</td><td>lr</td></tr><tr><td>SWI</td><td>lr</td></tr><tr><td>PABT</td><td>lr-4</td></tr><tr><td>DABT</td><td>lr-8</td></tr><tr><td>Reserved</td><td><br /></td></tr><tr><td>IRQ</td><td>lr-4</td></tr><tr><td>FIQ</td><td>lr-4</td></tr></tbody></table><br /><br /><br />Next we save the registers from r0 to r12.<br />Next we get the interrupt offset from the interrupt offset register. After this we load the program counter with the index to the handler in the interrupt_handler_jmp_table.<br /><br />Later code involves interrupt clean up by setting bits in source pending and interrupt pending registers. After this we restore the values r0 to r12 from the stack and load lr to pc to continue where we left off.<br /><br /><u>Note on the jump tables</u>:<br /><br />There are 2 jump tables present. The interrupt_handler_jmp_table and external_interrupt_handler_jmp_table. The 2 tables are array of functions pointers of the type void(*handler)(void).<br /><br /><br />This completes the generic parts of the interrupt handling by the MDK OS. I will add more details if I see anything lacking.<br /><br /><br /><div class="copy-paste-block" style="text-align: center;"><i><b>Restlessness is discontent and discontent  is the first necessity of progress. Show me a thoroughly satisfied man  and I will show you a failure. </b></i><b>&nbsp;</b><br /><b>--Thomas A. Edison</b><i><b><br /></b></i></div><div class="copy-paste-block" style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </div><div class="copy-paste-block" style="text-align: left;"></div></div>