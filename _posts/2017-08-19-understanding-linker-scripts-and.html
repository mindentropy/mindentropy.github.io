---
layout: post
title: Understanding linker scripts and walkthrough of it in MDK-OS.
date: '2017-08-19T14:28:00.000+05:30'
author: Gautam Bhat
tags:
- ARM
- linker scripts
- mini2440
- baremetal_os
- s3c2440
modified_time: '2017-08-23T07:46:57.975+05:30'
blogger_id: tag:blogger.com,1999:blog-2655423030126048565.post-1856796918676738725
blogger_orig_url: https://thesoulofamachine.blogspot.com/2017/08/understanding-linker-scripts-and.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">I wanted to write about a certain complex topic called linker scripts. Although the syntax being simple the topic is very vast. I will be taking an example from my OS. From here it is possible to expand and build on top of it. I will discuss the basics of the topic and will expand as I implement further techniques.<br /><br />Linker scripts are used by the linker (in GNU toolchain it is called ld). Linker scripts allow us to control the positioning and attributes of object code in the final output file.&nbsp; The linker "stitches" the various object code files into one single output file with instructions on how to position various "sections" of the program taken from the linker script file. The extension of a linker script is ".ld" or sometimes ".lds". The script is written using the linker command language.<br /><br />Linker always uses a the linker script. If you don't supply any linker scripts the linker will use an internal linker script which is compiled into the linker executable file. You can check out what the default linker script is by typing:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1</pre></td><td><pre style="line-height: 125%; margin: 0;">ld --verbose<br /></pre></td></tr></tbody></table></div><br />You can provide a linker script by providing a -T option. In my Makefile for the loader and mdkos I have two variables LOADER_LDSCRIPT and OD_LDSCRIPT with strings -Tloader.lds and -Tmdkos.lds respectively.<br /><br />As mentioned above the linker script combines different input files into a single output file. These&nbsp; files are in a special format called <i>object file format</i>. The files are called <i>object files</i>. Each of the object file has among other things called <i>sections</i>. The sections in input files are called <i>input sections</i>. Similarly the section in an output file is called an <i>output section</i>.<br /><br />Each section in an object file has a name and size.&nbsp; Most sections also have an associated block of data called <i>section contents</i>.&nbsp; A section may be marked as <i>loadable</i>, which means that the contents should be loaded into memory when the output file is run. A section with no contents may be <i>allocatable</i>, which means that an area in memory should be set aside, but nothing in particular should be loaded there (in some cases this memory must be zeroed out). A section which is neither loadable nor allocatable typically contains some sort of debugging information. <br /><br />You can see the different sections of an object file by using objdump with the -h option. For example to view the different sections in the mdk_loader elf file I input:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1</pre></td><td><pre style="line-height: 125%; margin: 0;">arm-none-eabi-objdump -h mdk_loader.elf<br /></pre></td></tr></tbody></table></div><br />Every object file also has a list of <i>symbols</i>, known as the <i>symbol table</i>. A symbol may be <i>defined</i> or <i>undefined</i>. Each symbol has a name, and each defined symbol has an address, among other information. If you compile a C or C++ program into an object file, you will get a <i>defined symbol</i> for every <b>defined function and global or static variable</b>. Every <b>undefined function or global variable</b> which is referenced in the input file will become an <i>undefined symbol</i>.<br />You can check the different symbols in the object file using the -t option for the objdump or use nm.<br />For example:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1</pre></td><td><pre style="line-height: 125%; margin: 0;">arm-none-eabi-objdump -t mdk_loader.elf<br /></pre></td></tr></tbody></table></div><br />Typically the different sections in your program and the place they reside can be:<br /><ul style="text-align: left;"><li><b>Constant data:</b> For example this can be const char teststr = "Test string". This type of information can safely be stored in ROM and used in place and need not be copied to say RAM.</li><li><b>Initialized variables: </b>For example int testint = 1234. This data my physically reside in RAM, the initial values to be loaded at boot time must be in ROM.</li><li><b>Uninitialized variables: </b>For example a declaration such as&nbsp; int testint;. These need not occupy any space in ROM. The start up code simply needs to allocate sufficient space in RAM for them, the linker needs to know how to resolve references to these variables.</li></ul>In addition we have<br /><ul style="text-align: left;"><li><b>Startup code </b>(hardware and C run-time initialization) code. This code is written in assembly and must be located at a specific place in ROM.</li><li><b>Application code:</b> This is distinct from startup code and usually doesn't have to reside anywhere specific in the memory map.</li></ul>Next we come to the difficult and confusing part of linker scripts. The "load memory address" (LMA) and the "virtual memory address"(VMA). Note that VMA has nothing to do with concepts of virtual, physical memory etc. Generally every loadable or allocatable section out section has these two addresses.<br /><br /><b>Virtual memory address (VMA): </b>This is the address the section will have when the output file is run. In the code this is the address which will be used as a reference by other parts of the code. Hence we would have to move code from the Load Memory Address to the Virtual Memory Address.<br /><b>Load memory address (LMA): </b>This the address the section will be loaded.<br />In most cases both the addresses will be the same. The case where they may differ is when say the .data section is loaded into ROM and then copied to RAM when the program starts up. In this case the ROM address would be the LMA and the RAM address is the VMA.<br /><br />An interesting example I have encountered previously was a device with low RAM probably about 4MB.&nbsp; This device had various applications to simplify it was less than 4MB but if added together would be greater than 4MB, somewhere around 50 - 100 MB monolithic application. The technique is called overlaying. All the applications were loaded into a huge NOR flash. All the applications had overlapping memory addresses in the RAM i.e. all the applications had references starting from the same address in the RAM. This is called the VMA.<br /><br />The application is a monolithic code. So the applications had been placed in the incrementing addresses i.e. the section was placed at incrementing address in the NOR flash. Now to load the application from the NOR flash to the RAM there was a small program called the loader. When a user wanted to go to a specific application he would select in the user interface (UI) and the loader would copy the application from the start address i.e. the LMA address and pastes it on to the RAM i.e. the VMA address and the program counter(PC) would jump to that particular address.<br /><br />We can inform ld where to load various parts of the program in two ways.<br /><br />The first is to assign names to various memory regions of our device and then direct each code or data section to the appropriate memory region. This is what is followed in my code.<br /><br />The second method is to start the linker's current memory location counter at a known address (the start address of the first section of the memory to be populated) and emit sections one by one to the current location, manually incrementing this location counter as appropriate in order to skip "holes" in the memory map. The "holes" in the memory map can be peripheral memory mapping etc.<br /><br />For eg:<br /><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3<br />4<br />5<br />6<br />7</pre></td><td><pre style="line-height: 125%; margin: 0;">SECTIONS<br />{<br />    . <span style="color: #333333;">=</span> <span style="color: #005588; font-weight: bold;">0x30000000</span>;<br />    .text <span style="color: #333333;">:</span> { <span style="color: #333333;">*</span>(.text) }<br />    .data <span style="color: #333333;">:</span> { <span style="color: #333333;">*</span>(.data) }<br />    .bss  <span style="color: #333333;">:</span> { <span style="color: #333333;">*</span>(.bss) }<br />}<br /></pre></td></tr></tbody></table></div><br />In this script we know that the RAM of the S3C2440 starts at 0x30000000. So we set the location counter at that location in the RAM. The line . = 0x30000000 achieves this.<br /><br />Next we tell ld which sections to include in the output file, where to emit them into memory and which sections of the input files should be mapped. The next 3 lines does this task. These lines basically say "collect all .text sections from the input files and emit them to a section called .text in the output file. Next collect all .data sections from the input file and emit them to a section called .data in the output file. Finally collect all .bss sections from the input file and emit them to a section called .bss in the output file".<br /><br />Now I will describe some of the linker script examples in the MDK OS.<br /><br />First we define the memory regions as follows:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3<br />4<br />5<br />6<br />7</pre></td><td><pre style="line-height: 125%; margin: 0;">MEMORY<br />{<br /> sram : org = 0x00000000 , len = 0x1000<br /> /*sdram : org = 0x30000000 , len = 0x4000000*/<br /> sdram : org = 0x30000000 , len = 0x3F00000 /* 63MB RAM */<br /> vectors : org = 0x33F00000 , len = 0x100000 /* Last 1MB for the isr handlers */<br />}<br /></pre></td></tr></tbody></table></div><br /><br />In the above case we have<br /><ol style="text-align: left;"><li>SRAM at location 0x0000 of size 4KB.&nbsp;</li><li>SDRAM at location 0x30000000 of size 64MB but I have commented it out. Instead I am keeping the SDRAM region size of 63MB reserving the last 1MB.</li><li>The last 1MB is reserved for the interrupt vectors and it is the vectors region.</li></ol>Next my different sections looks as follows:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14</pre></td><td><pre style="line-height: 125%; margin: 0;">.text :<br />{<br /> *(.text);<br /> . = ALIGN(4);<br />} &gt; sdram<br /><br /><br />.data :<br />{<br /> __data_start__ = .;<br /> *(.data);<br /> . = ALIGN(4);<br /> __data_end__ = .;<br />} &gt; sdram<br /></pre></td></tr></tbody></table></div><br /><br />In this section we have .text section loaded onto the "<b>sdram</b>" region. After this we also have the .data section loaded onto the "<b>sdram</b>" region.<br /><br />I have the __data_start__ = . and the __data_end__ =&nbsp; . which is extern'd in the code. These variables will be filled with the addresses of the start and end of the data section. Please note that the __data_start__ and __data_end__ is loaded with the VMA. In .data section the VMA and LMA is the same.<br /><br />Next we have the following section:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30</pre></td><td><pre style="line-height: 125%; margin: 0;">.rodata :<br />{<br /> __rodata_start__ = .;<br /> *(.rodata);<br /> . = ALIGN(4);<br /> __rodata_end__ = .;<br />} &gt; sdram<br /><br />.bss  :<br />{<br /> __bss_start__ = .;<br /> *(.bss); *(COMMON)<br /> __bss_end__ = .;<br /><br /> __usr_sys_stack_bottom__ = .;<br /> . += 0x1000;<br /> __usr_sys_stack_top__ = .;<br /><br /> __irq_stack_bottom__ = .;<br /> . += 0x1000;<br /> __irq_stack_top__ = .;<br /><br /> __fiq_stack_bottom__ = .;<br /> . += 0x1000;<br /> __fiq_stack_top__ = .;<br /><br /> __svc_stack_bottom__ = .;<br /> . += 0x1000;<br /> __svc_stack_top__ = .;<br />} &gt; sdram<br /></pre></td></tr></tbody></table></div><br />In the above example I have kept the ".rodata" or the read-only data in the SDRAM. This will be moved to ROM later on.<br /><br />Next we come to the .bss section which is the data section. All the data is clubbed and kept in the <b>"sdram" </b>memory region. We also setup the user, irq, fiq and svc stack sections each the size of 4KB. We also place markers which will be used in the assembly and C code for setup of stack.<br /><br />Next we come to the usage of the VMA and LMA concepts and that is in the interrupt handlers. We have the ld script as follows: <br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21</pre></td><td><pre style="line-height: 125%; margin: 0;">.vector_reloc :<br />{<br /> *(.vector_reloc);<br />} &gt;vectors AT&gt;sdram <br /><br />/* Get the lma address for the particular section */<br />__exception_vector_reloc_startaddr__ = LOADADDR(.vector_reloc);<br />__exception_vector_reloc_endaddr__ = LOADADDR(.vector_reloc) + SIZEOF(.vector_reloc);<br /><br />/* <br /> * Above SDRAM is where it will be stored in the file but address<br /> * references will be in the addresses of the isr handler section<br /> */<br /><br />.isrhandler :<br />{<br /> *(.isrhandler);<br />} &gt;vectors AT&gt;sdram<br /><br />__exception_handler_start_addr__ = LOADADDR(.isrhandler);<br />__exception_handler_end_addr__ = LOADADDR(.isrhandler) +  SIZEOF(.isrhandler);<br /></pre></td></tr></tbody></table></div><br />In this we have the <b>.vector_reloc </b>section at sdram which is the LMA denoted by AT&gt;sdram. The VMA is the <b>vectors</b> memory region which starts from 0x33F00000. Following this section is the <b>.isr_handler</b> section which is similar to above which has the LMA being in the SDRAM and the VMA being in the vectors memory region. We use LOADADDR to get the LMA of the section and SIZE to get the size of the section.<br /><br />In the previous case the variables __irq_stack_bottom__ etc is loaded with the VMA. Since the LMA and the VMA are the same in it we do not bother to use the LOADADDR and SIZE functions.<br /><br />How does all this come together?<br />The address generated and all the code references of the <b>vector_reloc </b>and <b>isr_handler</b> is the VMA. It is stored in the LMA though.The code for exception_vectors is present in os_vector.s in the section <b>vector_reloc</b>. The code snippet is as follows:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16</pre></td><td><pre style="line-height: 125%; margin: 0;">.section .vector_reloc,<span style="background-color: #fff0f0;">"ax"</span> <span style="color: #888888;">//Apparent fix for missing section when objcopy is to have allocatable and executable flags-"ax"</span><br /><span style="color: #888888;">//TODO: Understand the reason for the above flag.</span><br />.code <span style="color: #0000dd; font-weight: bold;">32</span><br /><br />.globl exception_vectors<br /><br /><span style="color: #997700; font-weight: bold;">exception_vectors:</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_reset  <span style="color: #888888;">//Reset vector</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_undef  <span style="color: #888888;">//Undefined instruction</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_swi   <span style="color: #888888;">//Software Interrupt</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_pabt   <span style="color: #888888;">//Abort prefetch</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_dabt  <span style="color: #888888;">//Abort data</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_reserved <span style="color: #888888;">//Reserved</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_irq  <span style="color: #888888;">//IRQ</span><br /> ldr pc,<span style="color: #333333;">=</span>do_handle_fiq  <span style="color: #888888;">//FIQ</span><br />.end<br /></pre></td></tr></tbody></table></div><br />The code for exception handling is present in the file exception_handler.s and in the section <b>isrhandler</b>. The snippet of the code is as follows:<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41</pre></td><td><pre style="line-height: 125%; margin: 0;">.section .isrhandler,<span style="background-color: #fff0f0;">"ax"</span><br /><br />.code <span style="color: #0000dd; font-weight: bold;">32</span><br /><br />.globl do_handle_reset<br /><span style="color: #997700; font-weight: bold;">do_handle_reset:</span><br /> b do_handle_reset<br /><br />.globl do_handle_undef<br /><span style="color: #997700; font-weight: bold;">do_handle_undef:</span><br /> b do_handle_undef<br /><br />.globl do_handle_swi<br /><span style="color: #997700; font-weight: bold;">do_handle_swi:</span><br /> b do_handle_swi<br /><br />.globl do_handle_pabt<br /><span style="color: #997700; font-weight: bold;">do_handle_pabt:</span><br /> b do_handle_pabt<br /><br />.globl do_handle_dabt<br /><span style="color: #997700; font-weight: bold;">do_handle_dabt:</span><br /> b do_handle_dabt<br /><br />.globl do_handle_reserved<br /><span style="color: #997700; font-weight: bold;">do_handle_reserved:</span><br /> b do_handle_reserved<br /><br />.globl do_handle_irq<br /><span style="color: #997700; font-weight: bold;">do_handle_irq:</span><br /><br />          ...<br />          ...<br /><br />.globl do_handle_fiq<br /><span style="color: #997700; font-weight: bold;">do_handle_fiq:</span><br />  b do_handle_fiq<br />...<br />...<br /><br />.end<br /></pre></td></tr></tbody></table></div><br />Please note that do_handle_irq contents and some other unrelated contents are replaced with "..." for clarity.<br /><br />The objdump of the section is as follows run with the following command:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1</pre></td><td><pre style="line-height: 125%; margin: 0;">arm-none-eabi-objdump -tDSl bin/mdk_os.elf<br /></pre></td></tr></tbody></table></div><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52<br />53<br />54</pre></td><td><pre style="line-height: 125%; margin: 0;">Disassembly of section <span style="color: #997700; font-weight: bold;">.vector_reloc</span>:<br /><br /><span style="color: #005588; font-weight: bold;">33f00000</span> &lt;<span style="color: #0066bb; font-weight: bold;">exception_vectors</span>&gt;:<br />exception_vectors():<br />33f00000: e59ff018  ldr pc, [pc, #24] ; 33f00020 &lt;exception_vectors+0x20&gt;<br />33f00004: e59ff018  ldr pc, [pc, #24] ; 33f00024 &lt;exception_vectors+0x24&gt;<br />33f00008: e59ff018  ldr pc, [pc, #24] ; 33f00028 &lt;exception_vectors+0x28&gt;<br />33f0000c: e59ff018  ldr pc, [pc, #24] ; 33f0002c &lt;exception_vectors+0x2c&gt;<br />33f00010: e59ff018  ldr pc, [pc, #24] ; 33f00030 &lt;exception_vectors+0x30&gt;<br />33f00014: e59ff018  ldr pc, [pc, #24] ; 33f00034 &lt;exception_vectors+0x34&gt;<br />33f00018: e59ff018  ldr pc, [pc, #24] ; 33f00038 &lt;exception_vectors+0x38&gt;<br />33f0001c: e59ff018  ldr pc, [pc, #24] ; 33f0003c &lt;exception_vectors+0x3c&gt;<br />33f00020: 33f00040  mvnscc r0, #64 ; 0x40<br />33f00024: 33f00044  mvnscc r0, #68 ; 0x44<br />33f00028: 33f00048  mvnscc r0, #72 ; 0x48<br />33f0002c: 33f0004c  mvnscc r0, #76 ; 0x4c<br />33f00030: 33f00050  mvnscc r0, #80 ; 0x50<br />33f00034: 33f00054  mvnscc r0, #84 ; 0x54<br />33f00038: 33f00058  mvnscc r0, #88 ; 0x58<br />33f0003c: 33f00098  mvnscc r0, #152 ; 0x98<br /><br />Disassembly of section <span style="color: #997700; font-weight: bold;">.isrhandler</span>:<br /><br /><span style="color: #005588; font-weight: bold;">33f00040</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_reset</span>&gt;:<br />do_handle_reset():<br />33f00040: eafffffe  b 33f00040 &lt;do_handle_reset&gt;<br /><br /><span style="color: #005588; font-weight: bold;">33f00044</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_undef</span>&gt;:<br />do_handle_undef():<br />33f00044: eafffffe  b 33f00044 &lt;do_handle_undef&gt;<br /><br /><span style="color: #005588; font-weight: bold;">33f00048</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_swi</span>&gt;:<br />do_handle_swi():<br />33f00048: eafffffe  b 33f00048 &lt;do_handle_swi&gt;<br /><br /><span style="color: #005588; font-weight: bold;">33f0004c</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_pabt</span>&gt;:<br />do_handle_pabt():<br />33f0004c: eafffffe  b 33f0004c &lt;do_handle_pabt&gt;<br /><br /><span style="color: #005588; font-weight: bold;">33f00050</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_dabt</span>&gt;:<br />do_handle_dabt():<br />33f00050: eafffffe  b 33f00050 &lt;do_handle_dabt&gt;<br /><br /><span style="color: #005588; font-weight: bold;">33f00054</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_reserved</span>&gt;:<br />do_handle_reserved():<br />33f00054: eafffffe  b 33f00054 &lt;do_handle_reserved&gt;<br /><br /><span style="color: #005588; font-weight: bold;">33f00058</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_irq</span>&gt;:<br />do_handle_irq():<br />...<br />...<br /><span style="color: #005588; font-weight: bold;">33f00098</span> &lt;<span style="color: #0066bb; font-weight: bold;">do_handle_fiq</span>&gt;:<br />do_handle_fiq():<br />33f00098: eafffffe  b 33f00098 &lt;do_handle_fiq&gt;<br /></pre></td></tr></tbody></table></div><br />Now that we have all the data we can start analysing the dumps. <br /><br />Firstly we verify the claim that all code references are using VMA regions. If we see the disassembly of the <b>vector_reloc </b>and <b>isrhandler </b>above we can see that the memory regions (the first column) are using the addresses from the vectors region which starts from 0x33F00000. After this the isrhandler follows which starts from 0x33F00040.<br /><br />Because all references are in the 0x33F0000 range we have to load the code in that memory range from the part of the RAM pointed to by the LMA to the VMA. To get the address of the LMA we use the following code.<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-weight: bold;">extern</span> <span style="color: #333399; font-weight: bold;">char</span> __exception_handler_start_addr__[];<br /><span style="color: #008800; font-weight: bold;">extern</span> <span style="color: #333399; font-weight: bold;">char</span> __exception_handler_end_addr__[];<br /><br /><span style="color: #008800; font-weight: bold;">extern</span> <span style="color: #333399; font-weight: bold;">char</span> __exception_vector_reloc_startaddr__[];<br /><span style="color: #008800; font-weight: bold;">extern</span> <span style="color: #333399; font-weight: bold;">char</span> __exception_vector_reloc_endaddr__[];<br /><br /><span style="color: #008800; font-weight: bold;">static</span> <span style="color: #333399; font-weight: bold;">void</span> <span style="color: #0066bb; font-weight: bold;">setup_interrupt_vector_table</span>()<br />{<br /><span style="color: #888888;">/*</span><br /><span style="color: #888888;"> * TODO: Optimize it to remove the extra index variables. Unoptimized only for test purposes.</span><br /><span style="color: #888888;"> *</span><br /><span style="color: #888888;"> */</span><br /><br /> <span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>vector_table <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>)EXCEPTION_INTERRUPT_VECTOR_TABLE_START;<br /><br /> <span style="color: #888888;">/* </span><br /><span style="color: #888888;">  * Need to get the lma of the code.</span><br /><span style="color: #888888;">  * The __exception_vector_reloc_startaddr__ is the lma i.e. the generated </span><br /><span style="color: #888888;">  * address in the file. I need to use this as the start address for the </span><br /><span style="color: #888888;">  * later vectors and handlers.</span><br /><span style="color: #888888;">  */</span><br /><br /> <span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>src <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">*</span>)__exception_vector_reloc_startaddr__; <br />      <br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> i <span style="color: #333333;">=</span> <span style="color: #0000dd; font-weight: bold;">0</span>;<br /><br /> <span style="color: #008800; font-weight: bold;">for</span>(i <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_vector_reloc_startaddr__; <br />   i<span style="color: #333333;">&lt;</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_vector_reloc_endaddr__; <br />    i<span style="color: #333333;">++</span>) {<br />  <span style="color: #333333;">*</span>vector_table <span style="color: #333333;">=</span> <span style="color: #333333;">*</span>src;<br />  vector_table<span style="color: #333333;">++</span>;<br />  src<span style="color: #333333;">++</span>;<br /> }<br /><br /><br /> <span style="color: #888888;">/* Continue with the same place for handler source  */</span><br /> <span style="color: #008800; font-weight: bold;">for</span>(i <span style="color: #333333;">=</span> (<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_handler_start_addr__; <br />     i<span style="color: #333333;">&lt;</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span>)__exception_handler_end_addr__;<br />     i<span style="color: #333333;">++</span>) {<br />  <span style="color: #333333;">*</span>vector_table <span style="color: #333333;">=</span> <span style="color: #333333;">*</span>src;<br />  vector_table<span style="color: #333333;">++</span>;<br />  src<span style="color: #333333;">++</span>;<br /> }<br /><br />}<br /></pre></td></tr></tbody></table></div><br />We extern the markers __exception_handler_start_addr__, __exception_handler_end_addr__ and __exception_vector_reloc_startaddr__,__exception_vector_reloc_endaddr__ .<br />The exception handler loading starts after the exception vector loading stops.<br /><br />We get back to the objdump disassembly to analyse further the addresses. We see the loading to of the PC (Program counter) with the function address of the handler. We take the first example starting at 0x33F0000 which is ldr pc, =do_handle_reset.<br /><br />The do_handle_reset symbol is located at 0x33F00040. To load this address we see that ldr PC, [PC, #24] (#24 is 0x18) which means load the contents of the memory present at PC+24. We face a small dilemma here. We see that the PC value is 0x33F00000. So the value after addition is 0x33F00018 (#24 is 0x18) but in the code we land to a value 0x59ff018 in that memory location 0x33F00018. Why is this?<br />According to the ARM guide we have the following:<br /><br /><i><b>Reading the program counter</b></i><br /><i><br />When an instruction reads the PC, the value read depends on which instruction set it comes from:<br /><br />For an ARM instruction, the value read is the address of the instruction plus 8 bytes. Bits [1:0] of this<br />value are always zero, because ARM instructions are always word-aligned.</i><br /><i><br /></i>Due to this we have actually have the PC value as 0x33F0000 + 0x8 when we do a read of the PC value in the LDR instruction. Hence PC value will be 0x33F00000 + 0x8 which is 0x33F00008. Next we have the addition of #24 which is 0x18 in hex which equals 0x33F00020. The value of that memory region is placed in the register PC. The value at that location is 0x33F00040. Hence the value of 0x33F00040 is placed in the PC which is address of the function do_handle_reset.<br /><br /><i></i>We observe something strange in the disassembly. We see the location 33F00020 has the following in the object dump.<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1</pre></td><td><pre style="line-height: 125%; margin: 0;">33f00020: 33f00040  mvnscc r0, #64 ; 0x40<br /></pre></td></tr></tbody></table></div><br />What does mvnscc mean? Why do we have some instructions present there which does not make no sense? Well it stumped me for sometime and then I realized that it is just a value placed in the memory. The PC loads that value which is the address of the do_handle_reset hence loads the instruction from there. Why it shows an instruction? This is because the disassembler just blindly decodes the value present. How did I come to this conclusion? I simply changed the <b>vectors</b> address to 0x32F0000 which loaded another instruction which had the value 0x32Fxxxxx.<br /><br />Finally how exactly do I make the interrupt handler jump to the address mentioned in the vectors when ARM states that the interrupt handlers should be in location 0x00000000? I just map the address 0x00000000 to the address 0x33F00000 in the MMU translation table. So when the CPU emits the address 0x00000000 it translates to 0x33F00000.<br /><br />This concludes the post on linker scripts. I will add any new things to this post if I come across anything interesting or make things even more clearer with examples.<br /><br />Finally I want to conclude with the memory map of the MDK OS.<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><pre style="line-height: 125%; margin: 0;">Memory Map Documentation:<br />=========================<br /><br /><br />+-------------------------+ ----&gt; 0x00000000<br />|                         |       ^<br />|   Initial bootloader    |       |---&gt; Stepping stone buffer.<br />|    (mdk_loader)      |       v<br />+-------------------------+ ----&gt; 0x00001000<br />|                         |<br />|                         |<br />|  Peripheral memory map  |<br />|          hole           |<br />.                         .<br />.                         .<br />.                         .<br />+-------------------------+ ----&gt; 0x30000000<br />|   mdk_os (.text)        |<br />|         .               |<br />|         .               |<br />|   mdk_os (.data)        |<br />|         .               |<br />|         .               |<br />|   mdk_os (.rodata)      |<br />|         .               |<br />|         .               |<br />|   mdk_os (.bss)         |<br />|         .               |<br />|         .               |<br />|   mdk_os (.stack)       |<br />.                         .<br />.                         .<br />.                         .<br />.                         .<br />+-------------------------+<br />+-------------------------+ ----&gt; 0x33F00000<br />|                         |<br />| Interrupt Vector table  |<br />| (section .vector_reloc) |<br />|                         |<br />+-------------------------+ ----&gt; 0x33F00020<br />|                         |<br />|                         |<br />| Interrupt handlers      |<br />| (section .isrhandler)   |<br />|                         |<br />|                         |<br />+-------------------------+ ----&gt; 0x34000000<br /></pre></div><br /><pre style="line-height: 125%; margin: 0;"></pre></div>