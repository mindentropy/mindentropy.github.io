---
layout: post
title: 'Code cleanup and refactoring in MDK-OS Clock setup '
date: '2016-04-03T17:05:00.004+05:30'
author: Gautam Bhat
tags: 
modified_time: '2016-04-03T17:17:35.118+05:30'
thumbnail: https://2.bp.blogspot.com/-NHR0GRKEW7Y/VvwarQk-vSI/AAAAAAAAADE/PzqmhyRvUvUHpsiDAftPEmun-thjopU-w/s72-c/clock_architecture.jpg
blogger_id: tag:blogger.com,1999:blog-2655423030126048565.post-8735501598617749080
blogger_orig_url: https://thesoulofamachine.blogspot.com/2016/04/code-cleanup-and-refactoring-in-mdk-os.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Clocks form an important part in any embedded system and configuration of this clock tree is very error prone. In the present code clean up I have parametrized the existing configurations which were hard coded. This is very error prone as any change in the base clock speed would cause a mismatch with the configuration.<br /><br />The first step I took in refactoring my code was to have helper functions to get FCLK, HCLK and PCLK. In the same vein I created a conditional compilation set up which compiles based on the board i.e. it being a MINI2440 or a MINI2410 etc. From the clock point of view the crystal used in these boards varies. The MINI2440 uses a clock source derived from a crystal based on OM3 and OM2 pins. The crystal as per the schematic is a 12Mhz crystal.<br /><br />With this as the base and using the helper functions the whole clock tree settings i.e the pre-scaler can be automated for different peripherals such as UART, SD MMC using formulae rather than hard coding values.<br /><br />First we will try to understand the different clocks signals generated by the control logic. There are 3 clock signals generated FCLK for the CPU, HCLK for the AHB bus peripherals, and PCLK for the APB bus peripherals.<br /><br />The S3C2440 has&nbsp; 2 PLL's one for FCLK, HCLK and PCLK and the other dedicated for USB block (48 MHz). The control logic can make slow clocks without the PLL's.<br /><br />What is a PLL and what does it do? PLL or a <b>P</b>hase <b>L</b>ocked <b>L</b>oop is a control system which generates an output signal whose phase is related to the phase of the input signal.&nbsp; Generally we use a PLL to generate a multiple of the input frequency. So the input to the PLL is a oscillator and output is a multiple of the input frequency. So in our case we have a 12MHz crystal oscillator which is given to the PLL's to generate multiples and keeping the phase locked with the input and output frequencies.<br />PLL's take time to stabilize. Hence there should be a way for the chip to work based on the oscillator frequency or an external signal. Once the PLL stabilizes and is able to generate a clean signal the chip can switch to the PLL frequency. <br /><br />The following is the clock architecture of the S3C2440.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-NHR0GRKEW7Y/VvwarQk-vSI/AAAAAAAAADE/PzqmhyRvUvUHpsiDAftPEmun-thjopU-w/s1600/clock_architecture.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="640" src="https://2.bp.blogspot.com/-NHR0GRKEW7Y/VvwarQk-vSI/AAAAAAAAADE/PzqmhyRvUvUHpsiDAftPEmun-thjopU-w/s640/clock_architecture.jpg" width="538" /></a></div><br />The main clock comes from the external crystal (XTlpll) or an external clock (EXTCLK). The clock generator includes an oscillator (Oscillation Amplifier), which is connected to an external crystal, and also has two PLL's (Phase locked loop) which generate the high frequency clock required in the S3C2440A.<br /><br /><br />&nbsp;The OM[3:2] status is latched internally by referring the OM3 and OM2 pins at the rising edge of nRESET as shown below<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-RZtyrX-MicE/VvwfMgEfDYI/AAAAAAAAADQ/Zjtf_RkbsEA-Ma2SI2uaUoTmzbbpBtNyA/s1600/om2_om3.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="https://2.bp.blogspot.com/-RZtyrX-MicE/VvwfMgEfDYI/AAAAAAAAADQ/Zjtf_RkbsEA-Ma2SI2uaUoTmzbbpBtNyA/s200/om2_om3.jpg" width="28" /></a></div>According to the data sheet the clock selection during boot-up is Crystal for the main clock source and USB.<br /><br />The MPLL&nbsp; starts just after a reset but the MPLL output is not used as the system clock until the software writes valid settings to the MPLLCON register. Before these settings, the clock from the external crystal or EXTCLK source will be used as the system clock directly. Even if the user does not want to change the default value of the MPLLCON register, the user should write the same value into the MPLLCON register.<br /><br />After the power on reset the crystal oscillator begins oscillation within several milliseconds. When nRESET is released after the OSC (XTIpll) clock the PLL starts to operate according the default PLL configuration. However the PLL is commonly known to be unstable after power-on reset so Fin is fed directly to the FCLK instead of the Mpll (PLL output) before the software newly configures PLLCON.<br /><br />The PLL restarts the lockup sequence toward the new frequency only after the software configures the PLL with a new frequency. FCLK can be configured as PLL output (Mpll) immediately after lock time.<br /><br />The wave form diagram below gives a clearer picture<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-xrISB8Pu0m8/VvwuhQwOw_I/AAAAAAAAADk/43dc0cVsHDoMJ52V8BoBNJqrXGT-k6bgQ/s1600/por_sequence_clock.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="280" src="https://1.bp.blogspot.com/-xrISB8Pu0m8/VvwuhQwOw_I/AAAAAAAAADk/43dc0cVsHDoMJ52V8BoBNJqrXGT-k6bgQ/s400/por_sequence_clock.jpg" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><br />For USB clock control and USB device interface needs 48MHz clock hence a dedicated USB PLL (UPLL) generates the clock.<br /><br />Now we come to coding the clock setup. The clock setup has to be parameterized.<br /><br />We come to the init_clock(..) function. Here we set the clock lock time to maximum. Next we do a set_clock_divn(..). Here we set the dividers. We divide the FCLK by 1, HDIVN by 4 and PDIVN by 8. Note that MPLL is fed into the CLKCNTL logic which generates the FCLK.<br /><br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3<br />4</pre></td><td><pre style="line-height: 125%; margin: 0;"> set_clock_divn(CLK_BASE_ADDR,<br />     DIVN_UPLL_BY_1,<br />     HDIVN_FCLK_BY_4,<br />     PDIVN_HCLK_BY_2);<br /></pre></td></tr></tbody></table></div><br /><br />So the final clock setup would be:<br /><br />&nbsp;FCLK = 405 MHz.<br />&nbsp;HCLK = 405/4 = 101MHz<br />&nbsp;PCLK = 405/8 = 50 MHz<br /><br />&nbsp;We need to setup the CPU to asynchronous mode. We can see the P 2-11 of ARM920T (Chapter 5). Also S3C2440 does not support synchronous mode.<br /><br />The code is as follows:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8</pre></td><td><pre style="line-height: 125%; margin: 0;">__asm__ <span style="color: #0066bb; font-weight: bold;">__volatile__</span>(<br />  <span style="background-color: #fff0f0;">"mrc p15,0,r1,c1,c0,0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />  <span style="background-color: #fff0f0;">"orr r1,r1,#0xC0000000</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />  <span style="background-color: #fff0f0;">"mcr p15,0,r1,c1,c0,0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />  <span style="color: #333333;">:</span> <span style="color: #888888;">/* No output */</span><br />  <span style="color: #333333;">:</span> <span style="color: #888888;">/* No input */</span><br />  <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">"r1"</span> <span style="color: #888888;">/* r1 clobbered */</span><br />  );<br /></pre></td></tr></tbody></table></div><br />Next we have to set the 2 PLL's. MPLL and UPLL.<br /><br />First we set the UPLL to generate 48 MHz as follows:<br /><br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14</pre></td><td><pre style="line-height: 125%; margin: 0;"> set_clk_upll(CLK_BASE_ADDR,<span style="color: #005588; font-weight: bold;">0x38</span>,<span style="color: #005588; font-weight: bold;">0x2</span>,<span style="color: #005588; font-weight: bold;">0x2</span>); <span style="color: #888888;">//48 MHz.</span><br />    <br /> __asm__ <span style="color: #0066bb; font-weight: bold;">__volatile__</span>(<br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />  );<br /></pre></td></tr></tbody></table></div><br />Note the mov r0,r0. This is used generate at least 7 NOPs.<br /><br />Next we set the MPLL to 405 MHz&nbsp; as follows:<br /><br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14</pre></td><td><pre style="line-height: 125%; margin: 0;"> set_clk_mpll(CLK_BASE_ADDR,<span style="color: #005588; font-weight: bold;">0x7f</span>,<span style="color: #005588; font-weight: bold;">0x2</span>,<span style="color: #005588; font-weight: bold;">0x1</span>); <span style="color: #888888;">//405 MHz</span><br /><br /> __asm__ <span style="color: #0066bb; font-weight: bold;">__volatile__</span>(<br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />   <span style="background-color: #fff0f0;">"mov r0,r0</span><span style="background-color: #fff0f0; color: #666666; font-weight: bold;">\n\t</span><span style="background-color: #fff0f0;">"</span><br />  );<br /></pre></td></tr></tbody></table></div><br />Finally we clear the slow clock register bits as follows.<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #557799;">#define clear_slow_clock(BA) do { \</span><br /><span style="color: #557799;"> clear_reg_bits(CLKSLOW_REG(BA),UCLK_ON); \</span><br /><span style="color: #557799;"> clear_reg_bits(CLKSLOW_REG(BA),MPLL_OFF); \</span><br /><span style="color: #557799;"> __asm__ __volatile__ ( \</span><br /><span style="color: #557799;">  "mov r0,r0 \n\t"  \</span><br /><span style="color: #557799;">  "mov r0,r0 \n\t"  \</span><br /><span style="color: #557799;">  "mov r0,r0 \n\t"  \</span><br /><span style="color: #557799;">  "mov r0,r0 \n\t"  \</span><br /><span style="color: #557799;">  "mov r0,r0 \n\t"  \</span><br /><span style="color: #557799;">  "mov r0,r0 \n\t"  \</span><br /><span style="color: #557799;"> ); \</span><br /><span style="color: #557799;"> clear_reg_bits(CLKSLOW_REG(BA),SLOW_BIT); \</span><br /><span style="color: #557799;"> } while(0)</span><br /></pre></td></tr></tbody></table></div><br />We clear the UCLK bit to turn on UPL. Next we turn on the MPLL and allow it settle which takes 300us. Hence we have NOPs for the delay. After this we turn OFF the slow clock to set the MPLL to the FCLK.<br /><br /><br />To get the current clocks I have written utility functions so that I can derive the different clocks just by reading the registers itself.<br /><br />First I have helper functions to get the dividers as follows:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #557799;">#define get_clk_pll_mdiv(PLL_REG) \</span><br /><span style="color: #557799;"> (((readreg32(PLL_REG)) &amp; MDIV_MASK) &gt;&gt; MDIV_SHIFT)</span><br /><br /><span style="color: #557799;">#define get_clk_pll_pdiv(PLL_REG) \</span><br /><span style="color: #557799;"> (((readreg32(PLL_REG)) &amp; PDIV_MASK) &gt;&gt; PDIV_SHIFT)</span><br /><br /><span style="color: #557799;">#define get_clk_pll_sdiv(PLL_REG) \</span><br /><span style="color: #557799;"> (((readreg32(PLL_REG)) &amp; SDIV_MASK) &gt;&gt; SDIV_SHIFT)</span><br /></pre></td></tr></tbody></table></div><br />Next I get the 2 PLL clock i.e. UPLL and MPLL based on the following helper functions:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #333399; font-weight: bold;">uint32_t</span> <span style="color: #0066bb; font-weight: bold;">get_mpll_clk</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span> BA)<br />{<br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> m,p,s;<br /> <br /> m <span style="color: #333333;">=</span> get_clk_pll_mdiv(MPLLCON_REG(BA)) <span style="color: #333333;">+</span> <span style="color: #0000dd; font-weight: bold;">8</span>;<br /> p <span style="color: #333333;">=</span> get_clk_pll_pdiv(MPLLCON_REG(BA)) <span style="color: #333333;">+</span> <span style="color: #0000dd; font-weight: bold;">2</span>;<br /> s <span style="color: #333333;">=</span> get_clk_pll_sdiv(MPLLCON_REG(BA));<br /><br /> <span style="color: #008800; font-weight: bold;">return</span> ((m <span style="color: #333333;">*</span> S3C_CLOCK_REFERENCE) <span style="color: #333333;">*</span> <span style="color: #0000dd; font-weight: bold;">2</span>)<span style="color: #333333;">/</span>(p <span style="color: #333333;">*</span> (<span style="color: #0000dd; font-weight: bold;">1</span><span style="color: #333333;">&lt;&lt;</span>s));<br />}<br /><br /><br /><span style="color: #333399; font-weight: bold;">uint32_t</span> <span style="color: #0066bb; font-weight: bold;">get_upll_clk</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span> BA)<br />{<br /> <br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> m,p,s;<br /> <br /> m <span style="color: #333333;">=</span> get_clk_pll_mdiv(UPLLCON_REG(BA)) <span style="color: #333333;">+</span> <span style="color: #0000dd; font-weight: bold;">8</span>;<br /> p <span style="color: #333333;">=</span> get_clk_pll_pdiv(UPLLCON_REG(BA)) <span style="color: #333333;">+</span> <span style="color: #0000dd; font-weight: bold;">2</span>;<br /> s <span style="color: #333333;">=</span> get_clk_pll_sdiv(UPLLCON_REG(BA));<br /><br /> <span style="color: #008800; font-weight: bold;">return</span> (m <span style="color: #333333;">*</span> S3C_CLOCK_REFERENCE)<span style="color: #333333;">/</span>(p <span style="color: #333333;">*</span> (<span style="color: #0000dd; font-weight: bold;">1</span><span style="color: #333333;">&lt;&lt;</span>s));<br />}<br /></pre></td></tr></tbody></table></div><br />To explain the above code I have to bring out the formulae. According the datasheet:<br /><br /><b>MPLL Control Register</b><br /><br />Mpll = (2 * m * Fin) / (p * 2 S)<br />m = (MDIV + 8), p = (PDIV + 2), s = SDIV<br /><br /><b>UPLL Control Register</b><br /><br />Upll = (m * Fin) / (p * 2 S)<br />m = (MDIV + 8), p = (PDIV + 2), s = SDIV<br /><br /><br /><br />Hence we get the m, p and s.<br /><br />Next we have the formula:<br /><br /><b>PLL Value Selection Guide (MPLLCON)</b> <br /><ol style="text-align: left;"><li>&nbsp;Fout = 2 * m * Fin / (p*(2^s) ), Fvco = 2 * m * Fin / p where: m=MDIV+8, p=PDIV+2, s=SDIV</li><li>&nbsp;600MHz ≤ FVCO ≤ 1.2GHz</li><li>&nbsp;200MHz ≤ FCLK OUT ≤ 600MHz</li></ol>In the above code we return the Fout formula.<br /><br />So to finally get the FCLK, HCLK,PCLK and the UCLK we have to check the dividers. We do divide the FCLK so we use Fout as is. Next for HCLK,PCLK and UCLK we have the following code:<br /><br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #333399; font-weight: bold;">uint32_t</span> <span style="color: #0066bb; font-weight: bold;">get_hclk</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span> BA)<br />{<br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> fclk <span style="color: #333333;">=</span> get_fclk(BA);<br /><br /> <span style="color: #008800; font-weight: bold;">switch</span>(get_clock_hdivn(BA)) {<br />  <span style="color: #008800; font-weight: bold;">case</span> HDIVN_FCLK_BY_1:<br />   <span style="color: #008800; font-weight: bold;">return</span> fclk;<br />  <span style="color: #008800; font-weight: bold;">case</span> HDIVN_FCLK_BY_2:<br />   <span style="color: #008800; font-weight: bold;">return</span> (fclk <span style="color: #333333;">&gt;&gt;</span> <span style="color: #0000dd; font-weight: bold;">1</span>);<br />  <span style="color: #008800; font-weight: bold;">case</span> HDIVN_FCLK_BY_4:<br />   <span style="color: #888888;">//TODO: CAMDIVN conditon check pending.</span><br />   <span style="color: #008800; font-weight: bold;">return</span> (fclk <span style="color: #333333;">&gt;&gt;</span> <span style="color: #0000dd; font-weight: bold;">2</span>);<br />  <span style="color: #008800; font-weight: bold;">case</span> HDIVN_FCLK_BY_3:<br />   <span style="color: #888888;">//TODO: CAMDIVN conditon check pending.</span><br />   <span style="color: #008800; font-weight: bold;">return</span> (fclk <span style="color: #333333;">/</span> <span style="color: #0000dd; font-weight: bold;">3</span>);<br /> }<br /><br /> <span style="color: #008800; font-weight: bold;">return</span> fclk;<br />}<br /><br /><span style="color: #333399; font-weight: bold;">uint32_t</span> <span style="color: #0066bb; font-weight: bold;">get_pclk</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span> BA)<br />{<br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> hclk <span style="color: #333333;">=</span> get_hclk(BA);<br /><br /> <span style="color: #008800; font-weight: bold;">switch</span>(get_clock_pdivn(BA)) {<br />  <span style="color: #008800; font-weight: bold;">case</span> PDIVN_HCLK_BY_1:<br />   <span style="color: #008800; font-weight: bold;">return</span> hclk;<br />  <span style="color: #008800; font-weight: bold;">case</span> PDIVN_HCLK_BY_2:<br />   <span style="color: #008800; font-weight: bold;">return</span> hclk <span style="color: #333333;">&gt;&gt;</span> <span style="color: #0000dd; font-weight: bold;">1</span>;<br /> }<br /><br /> <span style="color: #008800; font-weight: bold;">return</span> hclk;<br />}<br /><br /><span style="color: #333399; font-weight: bold;">uint32_t</span> <span style="color: #0066bb; font-weight: bold;">get_uclk</span>(<span style="color: #333399; font-weight: bold;">uint32_t</span> BA)<br />{<br /> <span style="color: #333399; font-weight: bold;">uint32_t</span> uclk <span style="color: #333333;">=</span> get_upll_clk(BA);<br /><br /> <span style="color: #008800; font-weight: bold;">switch</span>(get_clock_upll_divn(BA)) {<br />  <span style="color: #008800; font-weight: bold;">case</span> DIVN_UPLL_BY_1:<br />   <span style="color: #008800; font-weight: bold;">return</span> uclk;<br />  <span style="color: #008800; font-weight: bold;">case</span> DIVN_UPLL_BY_2:<br />   <span style="color: #008800; font-weight: bold;">return</span> uclk <span style="color: #333333;">&gt;&gt;</span> <span style="color: #0000dd; font-weight: bold;">2</span>;<br /> }<br /><br /> <span style="color: #008800; font-weight: bold;">return</span> uclk;<br />}<br /></pre></td></tr></tbody></table></div><br /><br />Note that the FCLK forms the base for the HCLK i.e. we divide the FCLK to get the HCLK. Next for the PCLK, HCLK forms the base i.e. we divide the HCLK to get the PCLK.<br /><br />For the UCLK we have the UPLL and hence we check the UDIVN and divide to get the final clock.<br /><br />So there you have it. The clock setup for the S3C2440. <br /><br /><div style="text-align: center;"><i><b>Time is an illusion</b></i></div><div style="text-align: center;"><i><b>--Albert Einstein </b></i></div></div>